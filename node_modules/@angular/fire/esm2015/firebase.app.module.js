/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, InjectionToken, NgModule, NgZone, Optional, PLATFORM_ID, VERSION as NG_VERSION, Version } from '@angular/core';
import * as firebase from 'firebase/app';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function FirebaseOptions() { }
/**
 * @record
 */
export function FirebaseAppConfig() { }
/** @type {?} */
export const FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');
/** @type {?} */
export const FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');
// Have to implement as we need to return a class from the provider, we should consider exporting
// this in the firebase/app types as this is our highest risk of breaks
export class FirebaseApp {
}
if (false) {
    /** @type {?} */
    FirebaseApp.prototype.name;
    /** @type {?} */
    FirebaseApp.prototype.options;
    /** @type {?} */
    FirebaseApp.prototype.analytics;
    /** @type {?} */
    FirebaseApp.prototype.auth;
    /** @type {?} */
    FirebaseApp.prototype.database;
    /** @type {?} */
    FirebaseApp.prototype.messaging;
    /** @type {?} */
    FirebaseApp.prototype.performance;
    /** @type {?} */
    FirebaseApp.prototype.storage;
    /** @type {?} */
    FirebaseApp.prototype.delete;
    /** @type {?} */
    FirebaseApp.prototype.firestore;
    /** @type {?} */
    FirebaseApp.prototype.functions;
    /** @type {?} */
    FirebaseApp.prototype.remoteConfig;
}
/** @type {?} */
export const VERSION = new Version('6.0.2');
/**
 * @param {?} options
 * @param {?} zone
 * @param {?=} nameOrConfig
 * @return {?}
 */
export function ɵfirebaseAppFactory(options, zone, nameOrConfig) {
    /** @type {?} */
    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';
    /** @type {?} */
    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};
    config.name = config.name || name;
    // Added any due to some inconsistency between @firebase/app and firebase types
    /** @type {?} */
    const existingApp = (/** @type {?} */ (firebase.apps.filter((/**
     * @param {?} app
     * @return {?}
     */
    app => app && app.name === config.name))[0]));
    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any
    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206
    return (/** @type {?} */ ((existingApp || zone.runOutsideAngular((/**
     * @return {?}
     */
    () => firebase.initializeApp(options, (/** @type {?} */ (config))))))));
}
/** @type {?} */
const FIREBASE_APP_PROVIDER = {
    provide: FirebaseApp,
    useFactory: ɵfirebaseAppFactory,
    deps: [
        FIREBASE_OPTIONS,
        NgZone,
        [new Optional(), FIREBASE_APP_NAME]
    ]
};
export class AngularFireModule {
    // tslint:disable-next-line:ban-types
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());
        firebase.registerVersion('angular', NG_VERSION.full);
    }
    /**
     * @param {?} options
     * @param {?=} nameOrConfig
     * @return {?}
     */
    static initializeApp(options, nameOrConfig) {
        return {
            ngModule: AngularFireModule,
            providers: [
                { provide: FIREBASE_OPTIONS, useValue: options },
                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }
            ]
        };
    }
}
AngularFireModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFireModule });
AngularFireModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFireModule_Factory(t) { return new (t || AngularFireModule)(ɵngcc0.ɵɵinject(PLATFORM_ID)); }, providers: [FIREBASE_APP_PROVIDER] });
/** @nocollapse */
AngularFireModule.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireModule, [{
        type: NgModule,
        args: [{
                providers: [FIREBASE_APP_PROVIDER]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZWJhc2UuYXBwLm1vZHVsZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvcmUvZmlyZWJhc2UuYXBwLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sSUFBSSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hJLE9BQU8sS0FBSyxRQUFRLE1BQU0sY0FBYyxDQUFDO0FBQ3pDO0FBQUk7QUFBVzs7QUFHZixxQ0FFQztBQUNEO0FBQ0c7QUFBVztBQUFkLHVDQUVDO0FBQ0Q7QUFDQSxNQUFNLE9BQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQWtCLDBCQUEwQixDQUFDO0FBQy9GO0FBQUEsTUFBTSxPQUFPLGlCQUFpQixHQUFHLElBQUksY0FBYyxDQUF5QywrQkFBK0IsQ0FBQztBQUM1SDtBQUNpRztBQUVqRyxNQUFNLE9BQU8sV0FBVztBQUFHLENBYTFCO0FBQ0Q7QUFDWTtBQUFxQixJQWQvQiwyQkFBYTtBQUNmO0FBQ00sSUFESiw4QkFBWTtBQUNkO0FBQXFCLElBQW5CLGdDQUFxQztBQUN2QztBQUFxQixJQUFuQiwyQkFBc0I7QUFDeEI7QUFBcUIsSUFBbkIsK0JBQXNEO0FBQ3hEO0FBQXFCLElBQW5CLGdDQUFxQztBQUN2QztBQUFxQixJQUFuQixrQ0FBMkM7QUFDN0M7QUFBcUIsSUFBbkIsOEJBQXFEO0FBQ3ZEO0FBQXFCLElBQW5CLDZCQUE0QjtBQUM5QjtBQUFxQixJQUFuQixnQ0FBcUM7QUFDdkM7QUFBcUIsSUFBbkIsZ0NBQW9EO0FBQ3REO0FBQXFCLElBQW5CLG1DQUE4QztBQUNoRDtBQUNBO0FBQ0EsTUFBTSxPQUFPLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQztBQUFVO0FBQUksUUFBUSxDQUFDO0FBRWhEO0FBQW1CO0FBQTRCO0FBQWU7QUFBeEUsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE9BQXdCLEVBQUUsSUFBWSxFQUFFLFlBQWdEO0FBQzVIO0FBQXFCLFVBQWIsSUFBSSxHQUFHLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxZQUFZLElBQUksV0FBVztBQUM5RTtBQUFxQixVQUFiLE1BQU0sR0FBRyxPQUFPLFlBQVksS0FBSyxRQUFRLElBQUksWUFBWSxJQUFJLEVBQUU7QUFDdkUsSUFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ3BDO0FBQ0U7QUFBcUIsVUFBZixXQUFXLEdBQUcsbUJBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNO0FBQU07QUFBc0I7QUFBbUI7QUFDdEYsSUFEd0MsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLEVBQU87QUFDNUYsSUFBRSxrR0FBa0c7QUFDcEcsSUFBRSw2RUFBNkU7QUFDL0UsSUFBRSxPQUFPLG1CQUFBLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxpQkFBaUI7QUFBTTtBQUFtQjtBQUFRLElBQWhDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLG1CQUFBLE1BQU0sRUFBTyxDQUFDLEVBQUMsQ0FBQyxFQUFlLENBQUM7QUFDdEgsQ0FBQztBQUNEO0FBQ2dCLE1BQVYscUJBQXFCLEdBQUc7QUFDOUIsSUFBRSxPQUFPLEVBQUUsV0FBVztBQUN0QixJQUFFLFVBQVUsRUFBRSxtQkFBbUI7QUFDakMsSUFBRSxJQUFJLEVBQUU7QUFDUixRQUFJLGdCQUFnQjtBQUNwQixRQUFJLE1BQU07QUFDVixRQUFJLENBQUMsSUFBSSxRQUFRLEVBQUUsRUFBRSxpQkFBaUIsQ0FBQztBQUN2QyxLQUFHO0FBQ0gsQ0FBQztBQUtELE1BQU0sT0FBTyxpQkFBaUI7QUFDOUI7QUFBMEM7QUFBUTtBQUE2QjtBQUFRLElBV3JGLFlBQWlDLFVBQWtCO0FBQ3JELFFBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUNqRixRQUFJLFFBQVEsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6RCxJQUFFLENBQUM7QUFDSDtBQUNNO0FBQTBCO0FBQWdDO0FBQW1CO0FBQVEsSUFoQnpGLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBd0IsRUFBRSxZQUF5QztBQUMxRixRQUFJLE9BQU87QUFDWCxZQUFNLFFBQVEsRUFBRSxpQkFBaUI7QUFDakMsWUFBTSxTQUFTLEVBQUU7QUFDakIsZ0JBQVEsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtBQUN4RCxnQkFBUSxFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFO0FBQzlELGFBQU87QUFDUCxTQUFLLENBQUM7QUFDTixJQUFFLENBQUM7QUFDSDs2Q0FiQyxRQUFRLFNBQUM7Q0FDUixTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxjQUNuQywrSkFDSTtBQUFDO0FBQW1CO0FBQ1UsWUFXWSxNQUFNLHVCQUF0QyxNQUFNLFNBQUMsV0FBVztBQUFROzs7Ozs7Ozs7a0NBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIE5nTW9kdWxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCwgVkVSU0lPTiBhcyBOR19WRVJTSU9OLCBWZXJzaW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgYW5hbHl0aWNzLCBhcHAsIGF1dGgsIGRhdGFiYXNlLCBmaXJlc3RvcmUsIGZ1bmN0aW9ucywgbWVzc2FnaW5nLCBwZXJmb3JtYW5jZSwgcmVtb3RlQ29uZmlnLCBzdG9yYWdlIH0gZnJvbSAnZmlyZWJhc2UvYXBwJztcblxuLy8gSU5WRVNUSUdBVEUgUHVibGljIHR5cGVzIGRvbid0IGV4cG9zZSBGaXJlYmFzZU9wdGlvbnMgb3IgRmlyZWJhc2VBcHBDb25maWcsIGlzIHRoaXMgdGhlIGNhc2UgYW55bG9uZ2VyP1xuZXhwb3J0IGludGVyZmFjZSBGaXJlYmFzZU9wdGlvbnMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VBcHBDb25maWcge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuPEZpcmViYXNlT3B0aW9ucz4oJ2FuZ3VsYXJmaXJlMi5hcHAub3B0aW9ucycpO1xuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX0FQUF9OQU1FID0gbmV3IEluamVjdGlvblRva2VuPHN0cmluZyB8IEZpcmViYXNlQXBwQ29uZmlnIHwgdW5kZWZpbmVkPignYW5ndWxhcmZpcmUyLmFwcC5uYW1lT3JDb25maWcnKTtcblxuLy8gSGF2ZSB0byBpbXBsZW1lbnQgYXMgd2UgbmVlZCB0byByZXR1cm4gYSBjbGFzcyBmcm9tIHRoZSBwcm92aWRlciwgd2Ugc2hvdWxkIGNvbnNpZGVyIGV4cG9ydGluZ1xuLy8gdGhpcyBpbiB0aGUgZmlyZWJhc2UvYXBwIHR5cGVzIGFzIHRoaXMgaXMgb3VyIGhpZ2hlc3QgcmlzayBvZiBicmVha3NcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZUFwcCBpbXBsZW1lbnRzIFBhcnRpYWw8YXBwLkFwcD4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9wdGlvbnM6IHt9O1xuICBhbmFseXRpY3M6ICgpID0+IGFuYWx5dGljcy5BbmFseXRpY3M7XG4gIGF1dGg6ICgpID0+IGF1dGguQXV0aDtcbiAgZGF0YWJhc2U6IChkYXRhYmFzZVVSTD86IHN0cmluZykgPT4gZGF0YWJhc2UuRGF0YWJhc2U7XG4gIG1lc3NhZ2luZzogKCkgPT4gbWVzc2FnaW5nLk1lc3NhZ2luZztcbiAgcGVyZm9ybWFuY2U6ICgpID0+IHBlcmZvcm1hbmNlLlBlcmZvcm1hbmNlO1xuICBzdG9yYWdlOiAoc3RvcmFnZUJ1Y2tldD86IHN0cmluZykgPT4gc3RvcmFnZS5TdG9yYWdlO1xuICBkZWxldGU6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGZpcmVzdG9yZTogKCkgPT4gZmlyZXN0b3JlLkZpcmVzdG9yZTtcbiAgZnVuY3Rpb25zOiAocmVnaW9uPzogc3RyaW5nKSA9PiBmdW5jdGlvbnMuRnVuY3Rpb25zO1xuICByZW1vdGVDb25maWc6ICgpID0+IHJlbW90ZUNvbmZpZy5SZW1vdGVDb25maWc7XG59XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJ0FOR1VMQVJGSVJFMl9WRVJTSU9OJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiDJtWZpcmViYXNlQXBwRmFjdG9yeShvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsIHpvbmU6IE5nWm9uZSwgbmFtZU9yQ29uZmlnPzogc3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcgfCBudWxsKSB7XG4gIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQ29uZmlnID09PSAnc3RyaW5nJyAmJiBuYW1lT3JDb25maWcgfHwgJ1tERUZBVUxUXSc7XG4gIGNvbnN0IGNvbmZpZyA9IHR5cGVvZiBuYW1lT3JDb25maWcgPT09ICdvYmplY3QnICYmIG5hbWVPckNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLm5hbWUgPSBjb25maWcubmFtZSB8fCBuYW1lO1xuICAvLyBBZGRlZCBhbnkgZHVlIHRvIHNvbWUgaW5jb25zaXN0ZW5jeSBiZXR3ZWVuIEBmaXJlYmFzZS9hcHAgYW5kIGZpcmViYXNlIHR5cGVzXG4gIGNvbnN0IGV4aXN0aW5nQXBwID0gZmlyZWJhc2UuYXBwcy5maWx0ZXIoYXBwID0+IGFwcCAmJiBhcHAubmFtZSA9PT0gY29uZmlnLm5hbWUpWzBdIGFzIGFueTtcbiAgLy8gV2Ugc3VwcG9ydCBGaXJlYmFzZUNvbmZpZywgaW5pdGlhbGl6ZUFwcCdzIHB1YmxpYyB0eXBlIG9ubHkgYWNjZXB0cyBzdHJpbmc7IG5lZWQgdG8gY2FzdCBhcyBhbnlcbiAgLy8gQ291bGQgYmUgc29sdmVkIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9wdWxsLzEyMDZcbiAgcmV0dXJuIChleGlzdGluZ0FwcCB8fCB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGZpcmViYXNlLmluaXRpYWxpemVBcHAob3B0aW9ucywgY29uZmlnIGFzIGFueSkpKSBhcyBGaXJlYmFzZUFwcDtcbn1cblxuY29uc3QgRklSRUJBU0VfQVBQX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBGaXJlYmFzZUFwcCxcbiAgdXNlRmFjdG9yeTogybVmaXJlYmFzZUFwcEZhY3RvcnksXG4gIGRlcHM6IFtcbiAgICBGSVJFQkFTRV9PUFRJT05TLFxuICAgIE5nWm9uZSxcbiAgICBbbmV3IE9wdGlvbmFsKCksIEZJUkVCQVNFX0FQUF9OQU1FXVxuICBdXG59O1xuXG5ATmdNb2R1bGUoe1xuICBwcm92aWRlcnM6IFtGSVJFQkFTRV9BUFBfUFJPVklERVJdXG59KVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJGaXJlTW9kdWxlIHtcbiAgc3RhdGljIGluaXRpYWxpemVBcHAob3B0aW9uczogRmlyZWJhc2VPcHRpb25zLCBuYW1lT3JDb25maWc/OiBzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogQW5ndWxhckZpcmVNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBGSVJFQkFTRV9PUFRJT05TLCB1c2VWYWx1ZTogb3B0aW9ucyB9LFxuICAgICAgICB7IHByb3ZpZGU6IEZJUkVCQVNFX0FQUF9OQU1FLCB1c2VWYWx1ZTogbmFtZU9yQ29uZmlnIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG5cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KFBMQVRGT1JNX0lEKSBwbGF0Zm9ybUlkOiBPYmplY3QpIHtcbiAgICBmaXJlYmFzZS5yZWdpc3RlclZlcnNpb24oJ2FuZ3VsYXJmaXJlJywgVkVSU0lPTi5mdWxsLCBwbGF0Zm9ybUlkLnRvU3RyaW5nKCkpO1xuICAgIGZpcmViYXNlLnJlZ2lzdGVyVmVyc2lvbignYW5ndWxhcicsIE5HX1ZFUlNJT04uZnVsbCk7XG4gIH1cbn1cbiJdfQ==